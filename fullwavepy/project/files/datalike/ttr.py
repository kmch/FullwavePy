"""
(c) 2019-2020 Kajetan Chrapkiewicz.
Copywright: Ask for permission writing to k.chrapkiewicz17@imperial.ac.uk.

"""
import numpy as np
import matplotlib.pyplot as plt
from autologging import logged, traced

from fullwavepy.generic.decor import timer
from fullwavepy.generic.parse import kw, del_kw, exten, strip
from fullwavepy.generic.system import bash, exists
from fullwavepy.seismic.data import Data
from fullwavepy.project.files.generic import BinaryProjFile, ArrayProjFile
from fullwavepy.ioapi.fw3d import TtrFile
from fullwavepy.ioapi.segy import SgyFile
from fullwavepy.project.files.datalike.generic import DataFile, SynDataFile, ObsDataFile


# -------------------------------------------------------------------------------


@traced
@logged
class DataFileTtr(DataFile, TtrFile):
  """
  """
  def __init__(self, suffix, proj, path, **kwargs):
    """
    
    """  
    self.suffix = suffix
    self.ext = 'ttr'
    super().__init__(proj, path, **kwargs)

  # ----------------------------------------------------------------------------- 

  def split(self, **kwargs):
    self.__log.warning('Not implemented. Skipping.')

  # -----------------------------------------------------------------------------
  
  def files(self, **kwargs):
    self.__log.warning('Not implemented. Skipping.')

  # -----------------------------------------------------------------------------


# -------------------------------------------------------------------------------
# SPECIFIC FILES (UNIQUE IDs)
# -------------------------------------------------------------------------------


@traced
@logged
class TemplateFileTtr(DataFile, TtrFile):
  """
  Files 2 & 3, containing Template, provide one SEG-Y trace for each synthetic trace that is to
  be generated by fullwave. These files specify the actual sources and receivers that must be
  modelled, and also provide pre-completed SEG-Y headers for the resulting synthetic data.
  Typically the template files will contain blank traces with SEG-Y headers derived directly from
  the field data that they are seeking to simulate. These files play an analogous role to that
  played previously by the Observed-0000.ttr file.  
  
  If we inherit from DataFileTtr instead, super().__init__ will need a suffix.
  """
  def __init__(self, proj, path, **kwargs):
    """
    
    """  
    self.suffix = 'Observed-0000'
    self.ext = 'ttr' #FIXME move to ttr
    #self.name = proj.name + '-Observed-0000.ttr'
    #self.fname = path + self.name
    super().__init__(proj, path, **kwargs)

  def read(self, **kwargs):
    raise NotImplementedError('convert_ttr2vtr_IMPROVED.f90 could not handle it')


# -------------------------------------------------------------------------------



@traced
@logged
class SynDataFileTtr(DataFileTtr, SynDataFile):
  def __init__(self, proj, path, **kwargs):
    suffix = 'Observed-Time'
    super().__init__(suffix, proj, path, **kwargs)
  

# -------------------------------------------------------------------------------


@traced
@logged
class ObsDataFileTtr(DataFileTtr, ObsDataFile):
  def __init__(self, proj, path, **kwargs):
    suffix = 'Observed-Time'
    super().__init__(suffix, proj, path, **kwargs)


# -------------------------------------------------------------------------------


@traced
@logged
class SignatureFileTtr(DataFileTtr):
  """
  
  """
  
  # -----------------------------------------------------------------------------     
  
  def __init__(self, proj, path, **kwargs):
    suffix = 'SourceSig-Time'
    super().__init__(suffix, proj, path, **kwargs)

  # ----------------------------------------------------------------------------- 
  
  def read(self, **kwargs):
    try:
      self.array = super().read(**kwargs)
    except FileNotFoundError as err: #FIXME? MOVE TO A MORE GENERAL CLASS
      self.__log.warning('%s not found. Now looking for a txt version...' % err)
      fname = self.fname
      self.fname = strip(fname) + '.txt'
      self.array = super().read(**kwargs)
      self.fname = fname
    return self.array
      

# -------------------------------------------------------------------------------


@traced
@logged
class DumpCompareFile(DataFileTtr):
  """
  DUMPCompare format, i.e.
    1. Traces of 1st kind
    3. Traces of 2nd kind
    
  """
  def __init__(self, suffix, proj, path, it, sid, **kwargs):
    super().__init__(suffix, proj, path, **kwargs)
    self.it = it
    self.sid = sid
    self.phase = {}
    #self.syn = SynDataFileTtr(suffix+'_syn', proj, path)
    #self.obs = ObsDataFileTtr(suffix+'_obs', proj, path)
    #self.dif = SynDataFileTtr(suffix+'_dif', proj, path)
    
  # -----------------------------------------------------------------------------      
  
  def _array_shape_from_head(self, **kwargs):
    assert hasattr(self, 'head')
    ntr = 3 * len(self.head) # 3x because DUMPCOMP has syn,obs,dif for the same trace id
    ns = self.head.ns.unique()[0]
    shape = (ntr, 1, ns)
    return shape

  # -----------------------------------------------------------------------------

  def read(self, **kwargs):
    """
    isep: 
    # SEPARATOR TO SPLIT ARRAY INTO 3 CHUNKS OF THE SAME LEN, CHECKED
    """
    from fullwavepy.seismic.data import Data    
    self.__log.info('Reading ' + self.fname + '...')

    self.read_header(**kwargs) # read header first to find out the shape of array to read => speedup!
    
    kwargs['shape'] = self._array_shape_from_head()
    self.array = super().read(**kwargs)
    
    
    isep  = int(len(self.array) / 3) 
    di = {'syn': Data(self.array[      :isep]),
          'obs': Data(self.array[+isep:-isep]),
          'dif': Data(self.array[-isep:     ]),
         }
    
    for key in di.keys():
      setattr(self, key, di[key])
    
    return di

  # -----------------------------------------------------------------------------
  
  def read_header(self, overwrite=False, **kwargs):
    """
    Add reading csv, useful for heavy sgy files.
    
    Offset is measured by Fullwave3D in 3D, not 2D like SegyPrep!
    This was the source of bugs but is now fixed.
    
    """
    if (not hasattr(self, 'head')) or overwrite:
      df = self.proj.i.obs.read_header(overwrite, **kwargs)
      
      # SELECT THE CORRECT SHOT
      recipr = bool(self.proj.i.sp.read()['reciprocity'])
      if recipr:
        df = df[df.tracf == self.sid]
      else:
        df = df[df.fldr == self.sid]
      
      # CALCULATE THE OFFSET
      self.__log.warning('Taking -gelev as this is positive for OBS PROTEUS, double-check land stations!')
      df['offset3d'] = np.sqrt((df['sx'] - df['gx'])**2 + 
                               (df['sy'] - df['gy'])**2 + 
                               (df['selev'] + df['gelev'])**2)
      
      
      # SELECT THE OFFSET RANGE AS IN ITERATION INFO
      minoff = kw('minoff', 0, self.proj.i.rnf.iters[self.it])
      maxoff = kw('maxoff', 1e9, self.proj.i.rnf.iters[self.it])
      self.__log.debug('minoff, maxoff for this iteration: {}, {}'.format(minoff, maxoff))
      df = df[(df.offset3d >= minoff) & (df.offset3d <= maxoff)]
      # RESET INDEX, OTHERWISE BUGGY split() ETC.
      df.reset_index(drop=True, inplace=True)       
      
      self.head = df
      
    return self.head  
  
  # -----------------------------------------------------------------------------

  def split(self, overwrite=False, **kwargs): # rename to read_n_split?
    kwargs['overwrite'] = overwrite
    self.read(**kwargs)
    self.read_header(**kwargs)
    
    if not (hasattr(self.syn, 'lid')) or overwrite:
      # LINE IDs
      lid_hw = self.proj.sgyhw['lid'] # IT SHOULD BE ep FOR PROTEUS
      lids = self.head[lid_hw].unique()
      
      for obj in [self.syn, self.obs, self.dif]:
        obj.lid = {}
        for lid in lids:
          subhead = self.head[:][self.head[lid_hw] == lid]
          obj.lid[lid] = Data(np.take(obj, indices=subhead.index, axis=0))
          obj.lid[lid].head = subhead
  
  # -----------------------------------------------------------------------------
  
  def _get_first_breaks(self, *args, **kwargs):
    """
    Note: it is hard to merge with SynDataFile one.
    
    """
    from fullwavepy.dsp.phase import first_breaks    
    Asyn, Aobs, Adif = self.read(**kwargs)
    self.fb = np.ravel(first_breaks(Asyn, *args, **kwargs))
    return self.fb
  
  # -----------------------------------------------------------------------------  
  
  def _get_phase(self, freq, overwrite=True, **kwargs):
    """
    
    Notes
    -----
    First breaks must be extracted from START-MOD
    synthetic data in all cases!
    Noise in observed.

    # I CHANGED BACK AFTER JO SAID THE ORIGINAL VERSION WAS OK
    # WE TAKE SYNTHETICS FROM THE START MOD FOR ALL ITERATIONS!
    #Bsyn, Bobs, Bdif = self.proj.out.dumpcomp.it[1][self.sid].read(**kwargs)
    #picks = first_breaks(Bsyn, **kwargs)
    
    Actually we should assume (ntraces, 1, nsamps) shape...
    
    """
    freq_max = self.proj.i.rnf.iters[self.it]['freq']
    if freq > freq_max:
      raise ValueError('You should not extract the phase at the freq. ' +
                       'above the iteration-block high-cut freq.: %s' % freq_max)
    
    if (not freq in self.phase) or overwrite:
      from fullwavepy.dsp.phase import first_breaks, extract_phase, wrap_phase
      from fullwavepy.numeric.generic import rms    
      self.__log.info('Getting phase info from ' + self.fname)
      
      self.read(**kwargs)
      self.read_header(**kwargs)
      
      if not hasattr(self, 'fb'):
        self.fb = first_breaks(self.syn, **kwargs)
      
      ph_syn = extract_phase(self.syn, self.fb, self.proj.dt, freq, **kwargs)
      ph_obs = extract_phase(self.obs, self.fb, self.proj.dt, freq, **kwargs)
      ph_dif = ph_syn - ph_obs
      
      ph_dif = np.array([[wrap_phase(i) for i in j] for j in ph_dif])
      ph_syn, ph_obs, ph_dif = [np.ravel(i) for i in [ph_syn, ph_obs, ph_dif]]
      
      self.rms_value = rms(ph_dif)
      self.__log.info('RMS of wrapped phase-differences: ' + 
                      str(self.rms_value))
      
      self.head['phase syn (%s Hz)' % freq] = ph_syn
      self.head['phase obs (%s Hz)' % freq] = ph_obs
      self.head['phase dif (%s Hz)' % freq] = ph_dif
      
      self.phase[freq] = {'syn': ph_syn,
                          'obs': ph_obs,
                          'dif': ph_dif}
    return self.phase[freq]
      
  # -----------------------------------------------------------------------------   
  
  # def exclude_bad_data(self, max_ph_dif, **kwargs):
  #   pass
  
  # -----------------------------------------------------------------------------  
  
  def plot(self, **kwargs):
    self.__log.info('Plotting whole content (syn, obs, dif) of ' + self.fname)
    self.read(**kwargs)
    kwargs['cmap'] = kwargs.get('cmap', 'seismic')
    kwargs['center_cmap'] = kwargs.get('center_cmap', True)
    return self.array.plot(**kwargs)
   
  # -----------------------------------------------------------------------------
  
  #def plot_line(self, **kwargs):
    #self.split(**kwargs)
    
   
  # -----------------------------------------------------------------------------
  
  #def compare(self, **kwargs):
    #from fullwavepy.plot.generic import compare
    #Asyn, Aobs, Adif = self.read(**kwargs)
    #compare(Asyn, Aobs)   
    
  # -----------------------------------------------------------------------------  
  
  def px_head(self, data_col, cmap='jet', **kwargs):
    import plotly.express as px
    fig = px.scatter(self.head, x='sx', y='sy', color=data_col, 
                     color_continuous_scale=cmap)
    return fig    

  # -----------------------------------------------------------------------------   
  
  def px_phase(self, freq, phase='dif', **kwargs):
    """
    Quick interactive plot. Can't do subplots with plotly :(
    
    Syntactic sugar: just a special case of px_head
    
    """
    import plotly.express as px
    
    self._get_phase(freq, **kwargs)
    
    data_col = 'phase %s (%s Hz)' % (phase, freq)
    fig = self.px_head(data_col, **kwargs)
    return fig
    
  # -----------------------------------------------------------------------------   
  
  def plot_phase(self, freq, arrow=None, box=None,**kwargs):
    """
    subtract : DataFile object
    
    Notes
    -----
    Cyclic colormaps ('hsv', 'twilight_shifted') would be preferred
    because so is the phase (periodic). But apparently jet, with 
    smoother colorscale (fewer colors) does better job...
    
    """
    cmap = kw('cmap', 'jet', kwargs)
    cbar = kw('cbar', True, kwargs)
    
    self._get_phase(freq, **kwargs)
    figsize = kwargs.get('figsize', [20,8])
    self.__log.info('Figsize: %s' % figsize)
    fig, ax = plt.subplots(1,3, figsize=figsize, constrained_layout=0)
    fig.suptitle('RMS of phase residuals: %.2f rad' % self.rms_value, y=1)
    
    for i, ph_type in enumerate(['syn', 'obs', 'dif']):
      ax = plt.subplot(1,3,i+1)
      ax.set_title(ph_type)
      ax.scatter(self.head.sx, self.head.sy, vmin=-np.pi, vmax=+np.pi, cmap=cmap,
                 c=self.head['phase %s (%s Hz)' % (ph_type, freq)])
      # if cbar: # DOESN'T WORK
      #   plt.colorbar()
      ax.scatter(self.head.gx[0], self.head.gy[0], s=20**2, 
                  marker='*', c='w', edgecolors='k')
      if arrow is not None:
        assert len(arrow) == 4
        arrow_width = kwargs.get('arrow_width', 0.1)
        arrow_color = kwargs.get('arrow_color', 'k')
        ax.arrow(*arrow, shape='full', width=arrow_width, \
          color=arrow_color)

      if box is not None:
        from fullwavepy.plot.misc import plot_box
        raise NotImplementedError()
      ax.set_xlabel('x, metres')
      ax.set_ylabel('y, metres')
      ax.set_aspect('equal')
      
  # -----------------------------------------------------------------------------
  

# -------------------------------------------------------------------------------


@traced
@logged
class DumpDataFile(DataFileTtr): # NOT USED?
  """
  DUMPDAT format, i.e.
    1. wavelets
    2. observed traces
    3. modelled traces
    
  """
  
  # -----------------------------------------------------------------------------
  
  def __init__(self, suffix, proj, path, sid, **kwargs):
    self.sid = sid
    super().__init__(suffix, proj, path, **kwargs)
  
  # -----------------------------------------------------------------------------      
  
  def read(self, **kwargs):
    #from fullwavepy.ioapi.fw3d import read_ttr
    #A = read_ttr(self.fname)
    #A = A[:, 0, :]
    #return A
    A = super().read(**kwargs)
    
    # READ SOURCE IDs
    self.__log.info('Ommiting first trace (the source wavelet)')
    A = A[1: ]
    
    imid = int(len(A) / 2)
    self.__log.info('Ommiting next ' + str(imid) +
                    '  trace(s) as observed data')    
    Aobs = A[ :imid]
    Asyn = A[imid: ]
    
    return Asyn

  # -----------------------------------------------------------------------------    


# -------------------------------------------------------------------------------


